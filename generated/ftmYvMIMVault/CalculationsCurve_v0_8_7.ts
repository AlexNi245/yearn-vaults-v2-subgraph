// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class CalculationsCurve_v0_8_7__cryptoPoolTokenAmountsUsdcResultValue0Struct extends ethereum.Tuple {
  get tokenAddress(): Address {
    return this[0].toAddress();
  }

  get tokenSymbol(): string {
    return this[1].toString();
  }

  get amountUsdc(): BigInt {
    return this[2].toBigInt();
  }
}

export class CalculationsCurve_v0_8_7 extends ethereum.SmartContract {
  static bind(address: Address): CalculationsCurve_v0_8_7 {
    return new CalculationsCurve_v0_8_7("CalculationsCurve_v0_8_7", address);
  }

  cryptoPoolLpPriceUsdc(lpAddress: Address): BigInt {
    let result = super.call(
      "cryptoPoolLpPriceUsdc",
      "cryptoPoolLpPriceUsdc(address):(uint256)",
      [ethereum.Value.fromAddress(lpAddress)]
    );

    return result[0].toBigInt();
  }

  try_cryptoPoolLpPriceUsdc(lpAddress: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "cryptoPoolLpPriceUsdc",
      "cryptoPoolLpPriceUsdc(address):(uint256)",
      [ethereum.Value.fromAddress(lpAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  cryptoPoolLpTotalValueUsdc(lpAddress: Address): BigInt {
    let result = super.call(
      "cryptoPoolLpTotalValueUsdc",
      "cryptoPoolLpTotalValueUsdc(address):(uint256)",
      [ethereum.Value.fromAddress(lpAddress)]
    );

    return result[0].toBigInt();
  }

  try_cryptoPoolLpTotalValueUsdc(
    lpAddress: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "cryptoPoolLpTotalValueUsdc",
      "cryptoPoolLpTotalValueUsdc(address):(uint256)",
      [ethereum.Value.fromAddress(lpAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  cryptoPoolTokenAmountUsdc(poolAddress: Address, tokenIdx: BigInt): BigInt {
    let result = super.call(
      "cryptoPoolTokenAmountUsdc",
      "cryptoPoolTokenAmountUsdc(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(poolAddress),
        ethereum.Value.fromUnsignedBigInt(tokenIdx)
      ]
    );

    return result[0].toBigInt();
  }

  try_cryptoPoolTokenAmountUsdc(
    poolAddress: Address,
    tokenIdx: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "cryptoPoolTokenAmountUsdc",
      "cryptoPoolTokenAmountUsdc(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(poolAddress),
        ethereum.Value.fromUnsignedBigInt(tokenIdx)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  cryptoPoolTokenAmountsUsdc(
    poolAddress: Address
  ): Array<
    CalculationsCurve_v0_8_7__cryptoPoolTokenAmountsUsdcResultValue0Struct
  > {
    let result = super.call(
      "cryptoPoolTokenAmountsUsdc",
      "cryptoPoolTokenAmountsUsdc(address):((address,string,uint256)[])",
      [ethereum.Value.fromAddress(poolAddress)]
    );

    return result[0].toTupleArray<
      CalculationsCurve_v0_8_7__cryptoPoolTokenAmountsUsdcResultValue0Struct
    >();
  }

  try_cryptoPoolTokenAmountsUsdc(
    poolAddress: Address
  ): ethereum.CallResult<
    Array<
      CalculationsCurve_v0_8_7__cryptoPoolTokenAmountsUsdcResultValue0Struct
    >
  > {
    let result = super.tryCall(
      "cryptoPoolTokenAmountsUsdc",
      "cryptoPoolTokenAmountsUsdc(address):((address,string,uint256)[])",
      [ethereum.Value.fromAddress(poolAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<
        CalculationsCurve_v0_8_7__cryptoPoolTokenAmountsUsdcResultValue0Struct
      >()
    );
  }

  cryptoPoolUnderlyingTokensAddressesByPoolAddress(
    poolAddress: Address
  ): Array<Address> {
    let result = super.call(
      "cryptoPoolUnderlyingTokensAddressesByPoolAddress",
      "cryptoPoolUnderlyingTokensAddressesByPoolAddress(address):(address[])",
      [ethereum.Value.fromAddress(poolAddress)]
    );

    return result[0].toAddressArray();
  }

  try_cryptoPoolUnderlyingTokensAddressesByPoolAddress(
    poolAddress: Address
  ): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "cryptoPoolUnderlyingTokensAddressesByPoolAddress",
      "cryptoPoolUnderlyingTokensAddressesByPoolAddress(address):(address[])",
      [ethereum.Value.fromAddress(poolAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  curveAddressesProviderAddress(): Address {
    let result = super.call(
      "curveAddressesProviderAddress",
      "curveAddressesProviderAddress():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_curveAddressesProviderAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "curveAddressesProviderAddress",
      "curveAddressesProviderAddress():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getBasePrice(lpAddress: Address): BigInt {
    let result = super.call("getBasePrice", "getBasePrice(address):(uint256)", [
      ethereum.Value.fromAddress(lpAddress)
    ]);

    return result[0].toBigInt();
  }

  try_getBasePrice(lpAddress: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getBasePrice",
      "getBasePrice(address):(uint256)",
      [ethereum.Value.fromAddress(lpAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getCurvePriceUsdc(lpAddress: Address): BigInt {
    let result = super.call(
      "getCurvePriceUsdc",
      "getCurvePriceUsdc(address):(uint256)",
      [ethereum.Value.fromAddress(lpAddress)]
    );

    return result[0].toBigInt();
  }

  try_getCurvePriceUsdc(lpAddress: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getCurvePriceUsdc",
      "getCurvePriceUsdc(address):(uint256)",
      [ethereum.Value.fromAddress(lpAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPoolFromLpToken(lpAddress: Address): Address {
    let result = super.call(
      "getPoolFromLpToken",
      "getPoolFromLpToken(address):(address)",
      [ethereum.Value.fromAddress(lpAddress)]
    );

    return result[0].toAddress();
  }

  try_getPoolFromLpToken(lpAddress: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getPoolFromLpToken",
      "getPoolFromLpToken(address):(address)",
      [ethereum.Value.fromAddress(lpAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getPriceUsdc(assetAddress: Address): BigInt {
    let result = super.call("getPriceUsdc", "getPriceUsdc(address):(uint256)", [
      ethereum.Value.fromAddress(assetAddress)
    ]);

    return result[0].toBigInt();
  }

  try_getPriceUsdc(assetAddress: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPriceUsdc",
      "getPriceUsdc(address):(uint256)",
      [ethereum.Value.fromAddress(assetAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getUnderlyingCoinFromPool(poolAddress: Address): Address {
    let result = super.call(
      "getUnderlyingCoinFromPool",
      "getUnderlyingCoinFromPool(address):(address)",
      [ethereum.Value.fromAddress(poolAddress)]
    );

    return result[0].toAddress();
  }

  try_getUnderlyingCoinFromPool(
    poolAddress: Address
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getUnderlyingCoinFromPool",
      "getUnderlyingCoinFromPool(address):(address)",
      [ethereum.Value.fromAddress(poolAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getVirtualPrice(lpAddress: Address): BigInt {
    let result = super.call(
      "getVirtualPrice",
      "getVirtualPrice(address):(uint256)",
      [ethereum.Value.fromAddress(lpAddress)]
    );

    return result[0].toBigInt();
  }

  try_getVirtualPrice(lpAddress: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getVirtualPrice",
      "getVirtualPrice(address):(uint256)",
      [ethereum.Value.fromAddress(lpAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isBasicToken(tokenAddress: Address): boolean {
    let result = super.call("isBasicToken", "isBasicToken(address):(bool)", [
      ethereum.Value.fromAddress(tokenAddress)
    ]);

    return result[0].toBoolean();
  }

  try_isBasicToken(tokenAddress: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isBasicToken", "isBasicToken(address):(bool)", [
      ethereum.Value.fromAddress(tokenAddress)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isCurveLpToken(lpAddress: Address): boolean {
    let result = super.call(
      "isCurveLpToken",
      "isCurveLpToken(address):(bool)",
      [ethereum.Value.fromAddress(lpAddress)]
    );

    return result[0].toBoolean();
  }

  try_isCurveLpToken(lpAddress: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isCurveLpToken",
      "isCurveLpToken(address):(bool)",
      [ethereum.Value.fromAddress(lpAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isLpCryptoPool(lpAddress: Address): boolean {
    let result = super.call(
      "isLpCryptoPool",
      "isLpCryptoPool(address):(bool)",
      [ethereum.Value.fromAddress(lpAddress)]
    );

    return result[0].toBoolean();
  }

  try_isLpCryptoPool(lpAddress: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isLpCryptoPool",
      "isLpCryptoPool(address):(bool)",
      [ethereum.Value.fromAddress(lpAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isPoolCryptoPool(poolAddress: Address): boolean {
    let result = super.call(
      "isPoolCryptoPool",
      "isPoolCryptoPool(address):(bool)",
      [ethereum.Value.fromAddress(poolAddress)]
    );

    return result[0].toBoolean();
  }

  try_isPoolCryptoPool(poolAddress: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isPoolCryptoPool",
      "isPoolCryptoPool(address):(bool)",
      [ethereum.Value.fromAddress(poolAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  ownerAddress(): Address {
    let result = super.call("ownerAddress", "ownerAddress():(address)", []);

    return result[0].toAddress();
  }

  try_ownerAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall("ownerAddress", "ownerAddress():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  yearnAddressesProviderAddress(): Address {
    let result = super.call(
      "yearnAddressesProviderAddress",
      "yearnAddressesProviderAddress():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_yearnAddressesProviderAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "yearnAddressesProviderAddress",
      "yearnAddressesProviderAddress():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _bandReference(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _oracle(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _curveAddressesProviderAddress(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class SetOwnerAddressCall extends ethereum.Call {
  get inputs(): SetOwnerAddressCall__Inputs {
    return new SetOwnerAddressCall__Inputs(this);
  }

  get outputs(): SetOwnerAddressCall__Outputs {
    return new SetOwnerAddressCall__Outputs(this);
  }
}

export class SetOwnerAddressCall__Inputs {
  _call: SetOwnerAddressCall;

  constructor(call: SetOwnerAddressCall) {
    this._call = call;
  }

  get _ownerAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetOwnerAddressCall__Outputs {
  _call: SetOwnerAddressCall;

  constructor(call: SetOwnerAddressCall) {
    this._call = call;
  }
}

export class UpdateCurveAddressesProviderAddressCall extends ethereum.Call {
  get inputs(): UpdateCurveAddressesProviderAddressCall__Inputs {
    return new UpdateCurveAddressesProviderAddressCall__Inputs(this);
  }

  get outputs(): UpdateCurveAddressesProviderAddressCall__Outputs {
    return new UpdateCurveAddressesProviderAddressCall__Outputs(this);
  }
}

export class UpdateCurveAddressesProviderAddressCall__Inputs {
  _call: UpdateCurveAddressesProviderAddressCall;

  constructor(call: UpdateCurveAddressesProviderAddressCall) {
    this._call = call;
  }

  get _curveAddressesProviderAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UpdateCurveAddressesProviderAddressCall__Outputs {
  _call: UpdateCurveAddressesProviderAddressCall;

  constructor(call: UpdateCurveAddressesProviderAddressCall) {
    this._call = call;
  }
}

export class UpdateYearnAddressesProviderAddressCall extends ethereum.Call {
  get inputs(): UpdateYearnAddressesProviderAddressCall__Inputs {
    return new UpdateYearnAddressesProviderAddressCall__Inputs(this);
  }

  get outputs(): UpdateYearnAddressesProviderAddressCall__Outputs {
    return new UpdateYearnAddressesProviderAddressCall__Outputs(this);
  }
}

export class UpdateYearnAddressesProviderAddressCall__Inputs {
  _call: UpdateYearnAddressesProviderAddressCall;

  constructor(call: UpdateYearnAddressesProviderAddressCall) {
    this._call = call;
  }

  get _yearnAddressesProviderAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UpdateYearnAddressesProviderAddressCall__Outputs {
  _call: UpdateYearnAddressesProviderAddressCall;

  constructor(call: UpdateYearnAddressesProviderAddressCall) {
    this._call = call;
  }
}
